---
title: "Visualizations with Hilbert Curves"
author: "Paul Gellerman"
date: "May 20, 2016"
output: 
    ioslides_presentation:
        css: style.css
        widescreen: true
        smaller: true


---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Space Filling Curves
<div class="col2">
<p><img src="./images/Hilbert_curve.svg" alt="Hilcurve" style="height: 275px; PADDING-RIGHT: 30px"/></p>
<p><img src="./images/peano_curve.png" alt="peano" style="height: 275px;"/></p>
</div> 
  
  
- Limit of a function that passes through every point in space.  
- Peano, Hilbert, Z-curves, others.  
- All have slightly different properties and generating algorithms, but the same basic principles apply.   

## Neat picture, who cares?
<div class="col2">
<p><img src="./images/rgb-hilbert.png" alt="rgb-hil" style="height: 250px; PADDING-LEFT: 20px"/></p>
<p><img src="./images/rgb-seq.png" alt="rgb-seq" style="height: 250px;"/></p>
</div>

<p><img src="./images/rgb-line.png" alt="rgb-line" style="height: 50px;"/></p>

- Preserves locality of points from one dimension into two.  
- Points that are close in one dimension are close in two.  
- Can display very dense information in a compact form.  

## Recursion
<div class="col2">
<p><img src="./images/recursion.jpg" style="height: 225px;"/></p>
<p><img src="./images/hogan_recursion.jpg" style="height: 225px;"/></p>
</div>

* Requires two main components:
    + Terminating condition
    + Code to execute
* Think about deleting a folder with several sub-folders:
    + What is the terminating condition?
    + What is the code being executed?
    
## Hilbert's Heart
```{r, eval=FALSE, echo=TRUE}
xlist <<- {}
ylist <<- {}
hilbert <- function(x0,y0,xi,xj,yi,yj,n){
    if (n <= 0){
        x <- (x0 +(xi+yi)/2)
        y <- (y0 +(xj+yj)/2)
        xlist <<- c(xlist,x)
        ylist <<- c(ylist,y)
    } else {
        hilbert(x0, y0, yi/2, yj/2, xi/2, xj/2, n-1)
        hilbert(x0+xi/2,y0+xj/2,xi/2,xj/2,yi/2,yj/2,n-1)
        hilbert(x0+xi/2+yi/2,y0+xj/2+yj/2,xi/2,xj/2,yi/2,yj/2,n-1)
        hilbert(x0+xi/2+yi, y0+xj/2+yj,-yi/2,-yj/2,-xi/2,-xj/2,n-1)
    }
}
```
Adapted from Andrew Cumming - Napier University Edinburgh - psuedo code.

## What was that?
* Terminating condition
```{r, eval=FALSE, echo=TRUE}
    if (n <= 0){
    }
```
```{r, eval=FALSE, echo=TRUE}
    hilbert(...,n-1)
```
* Code to execute
```{r, eval=FALSE, echo=TRUE}
        x <- (x0 +(xi+yi)/2)
        y <- (y0 +(xj+yj)/2)
        xlist <<- c(xlist,x)
        ylist <<- c(ylist,y)
```
```{r, eval=FALSE, echo=TRUE}
        hilbert(x0, y0, yi/2, yj/2, xi/2, xj/2, n-1)
        hilbert(x0+xi/2,y0+xj/2,xi/2,xj/2,yi/2,yj/2,n-1)
        hilbert(x0+xi/2+yi/2,y0+xj/2+yj/2,xi/2,xj/2,yi/2,yj/2,n-1)
        hilbert(x0+xi/2+yi, y0+xj/2+yj,-yi/2,-yj/2,-xi/2,-xj/2,n-1)
```

## In English.
* It's not very clear.  Recursive functions can be really hard to track.  
* n tells you how many times to divide the 1 dimensional space (x and y unit vectors)
* When the code is executed the hilbert function is repeatedly called until n <= 0 
* Once n <= 0 it calculates the mid point of the space's division and stores it's x and y in the xlist and ylist respectively
* This generates an ordered list of each point on the curve.  

## Graphic
* Connecting the dots yields:
<p><img src="./images/hilbert-65536.png" alt="hil65536" style="height: 500px;"/></p>

## How to use it
* Requires some helper functions that will take the Hilbert curves index and map the point so of interest to those values.  
* Functions to:
    + Set up ranges
    + Assign values to range
    + Count number of values in range
    + Shade the value of the range based off it's min and max  (heatmap)

* Example data: SNORT IP Blacklists

## Test
```{r, eval=TRUE, echo=TRUE}
        source('./hilbertmaker.R')
        clearHilbert()
        hilbert(0,0,1,0,0,1,2)
```
```{r, eval=TRUE, echo=FALSE}
        print("Xlist",head(xlist))
        print("Ylist",head(ylist))
```